Проект можно разделить на несколько функционально законченных частей, каждая из которых тестируется независимо, а именно:
- Python-скрипты для обработки поступающей от пользователя информации, включающие ML-модель, которая выделяет ключевые слова из текста
- Kotlin-скрипт для построения маршртуа и формирования JSON для отправки на клиент
- Клиентское Android-приложение, написанное на Kotlin

Для каждой части есть свой сценарий тестирования, описанный ниже. После того, как будут протестированы отдельные части приложения, весь проект будет протестирован целиком. 

### Тестирование Python-части приложения (скрипты и модель машинного обучения)

Необходимо написать Unit-тест, подающий на вход модели текст запроса с заранее известными ключевыми словами, далее произвести сравнение известных ключевых слов с полученными от модели результатами. Тест считается пройденным, если в выдаче есть необходимые ключевые слова. Поскольку ML-модель не является детерминированным алгоритмом, нельзя заранее сказать, какой именно будет выдача. Однако, необходимо строгое наличие важных слов в тексте, без него тест не будет считаться пройденным. Предусмотреть лог промежуточных результатов с указанием даты и времени тестирования.

Также провести ручное тестирование формирования JSON-файла для передачи Kotlin-скрипту при различных комбинациях входных данных.
Еще необходимо провести ручное тестирование парсинга входящего JSON-файла на сервер.



### Тестирование Kotlin-части приложения

Unit тесты по беку приложения по части обработки JSON пакета. На входе - JSON файл, сгенерированный предыдущим скриптом. На выходе - JSON с маршрутом для отправки на клиент. Необходимо увидеть, что в выходном файле есть необходимые поля, соответствующие запросу.

### Функциональное тестирование

Ручной тест прохождения пользователем всей цепочки действий. Ввод запроса -> обработка запроса моделью -> отправка данных на API карт -> получение данных с API карт приложением -> отображение на интерфейсе. Ручное логирование действий пользователя.


### Тест-план Python-части

1. Тестирование парсинга входящих на сервер JSON
2. Тестирование распознавателя ключевых слов
3. Тестирование формирователя JSON для передачи Kotlin-скрипту

#### Тестирование парсинга входящих JSON на сервер

**Основное действующее лицо:** пользователь\
**Гарантия успеха:** в поступившем от пользователя на вход JSON правильно выделены следующие поля с данными: тип ТС, текст запроса, координаты текущей точки. "Правильно" означает, что нет потерь данных и у русского текста не слетела кодировка.
**Триггер:** поступление запроса от пользователя\
**Основной сценарий:** 
1. из поступающего на вход JSON выделяется текст, тип ТС и координаты текущего местоположения

Тестирование проводилось вручную с помощью Postman. На сервере в командную строку выводился полученный JSON. Через Postman по известному IP-адресу отправлялись следующие запросы. Всего было отправлено 5 разных запросов - см. ниже. Тест считается пройденным, если запрос и выдача в консоли совпали.

    {
    "tsys": "bike",
    "text": "хочу поехать на машине в кино потом на машине в кафе",
    "coords": "59.904775,30.310820"
    }
    {
    "tsys": "car",
    "text": "хочу поехать на в кино потом на велосипеде в кафе",
    "coords": "59.904775,30.310820"
    }
    {
    "tsys": "",
    "text": "хочу поехать на в кино потом на велосипеде в кафе",
    "coords": "59.904775,30.310820"
    }
    {
    "tsys": "",
    "text": "тест тест тест",
    "coords": "59.904775,30.310820"
    }
    {
    "tsys": "",
    "text": "тест тест тест",
    "coords": "60.020930,30.318734"
    }

Выше можно увидеть выдачу в консоли для 5 подряд идущих запросов. Ровно такие запросы и поступали от Postman, значит, все принято верно.

#### Тестирование распознавателя ключевых слов

**Основное действующее лицо:** пользователь\
**Гарантия успеха:** в поступившем от пользователя на вход тексте правильно выделены ключевые слова (присутствует желаемая точка, тип транспорта и желаемое время - при наличии, если что-то отсутствует - см.ниже)\
**Триггер:** появление на сервере результата парсинга JSON\
**Основной сценарий:** 
1. из поступающего на вход JSON выделяется текст и координаты текущего местоположения (предыдущий пункт)
2. из текста выделяются ключевые слова (желаемая точка, желаемое время, тип транспортного средства)
3. на основе полученных данных формируется JSON для отправки на вход Kotlin (следующий пункт)

**Расширение:**
1. Пользователь не указал тип транспортного средства (далее ТС) в запросе, но указал его, нажав на кнопку в приложении. В таком случае тип ТС определяется по нажатой иконке
2. Пользователь не нажал тип ТС в приложении, но указал в запросе. В таком случае тип ТС определяется из запроса.
3. Пользователь указал разный тип ТС в запросе и в приложении (здесь и далее под "в приложении") подразумевается нажатие соответствующей иконки. В таком случае приоритет отдается запросу.
4. Пользователь не указал тип ТС вообще. В таком случае считается по умолчанию, что пользователь идет пешком.
5. Пользователь не указал желаемое время поездки. В таком случае для автомобиля по умолчанию ставится 15 минут, для велосипеда - 30, для пешего маршрута - 30 минут, для общественного транспорта - 30 минут. 
6. Пользователь отправил пустой запрос. Такой запрос обработан не будет, и приложение уведомит пользователя об этом.
7. Пользователь не указал желаемую точку. В таком случае будет построен маршрут, оставлющий пользователя в текущей точке.
8. Если запрос составной, то если не указан тип ТС во второй части, но есть в первой, то считаем, что тип ТС не менялся.

Тестирование распознавания ключевых слов проводится с помощью авто-тестов. Тестирование формирования JSON - вручную.

Для тестирования было сгенерировано 10 пользовательских запросов. Запросы генерировались с помощью ChatGPT, а затем редактировались. После правок получились следующие запросы (примеры):

1. я хочу пойти в ближайшую парикмахерскую пешком затем поехать в аптеку на автобусе
2. хочу поехать в парк на велосипеде в течение часа затем заехать в кафе
3. поеду в обувной магазин на машине потом в кино
4. в библиотеку на машине и обратно
5. пойду в парк пешком далее в торговый центр на автобусе


Все предложения состоят из двух частей и не имеют знаков препинания и заглавных букв (это результат распознавания речи). Ожидается, что в выдаче будет тип транспорта, время в пути и само место. Время переводится в минуты, если указаны часы.


Для тестирования выделения ключевых слов был написан следующий код (с использованием встроенной библиотеки unittest). Пример кода для 3х запросов:

    import unittest
    from keyword_extraction import extract

    class TestKeywordExtraction(unittest.TestCase):

        def test_extract_keywords_from_text1(self):
            expected_keywords1 = ['пешком', 'парикмахерская', 'аптека', 'автобус']
            self.assertEqual(expected_keywords1, extract('texts_for_testing/test_text_1.txt',
                                                     'texts_for_testing/result1.txt'))

        def test_extract_keywords_from_text2(self):
            expected_keywords2 = ['парк', 'велосипед', 'один', 'час', 'кафе']
            self.assertEqual(expected_keywords2, extract('texts_for_testing/test_text_2.txt',
                                                     'texts_for_testing/result2.txt'))

        def test_extract_keywords_from_text3(self):
            expected_keywords3 = ['машина', 'обувной', 'магазин', 'кино']
            self.assertEqual(expected_keywords3, extract('texts_for_testing/test_text_3.txt',
                                                     'texts_for_testing/result3.txt'))


Ниже приведена таблица тестов и полученных результатов. Все тесты пройдены успешно, результаты совпали с ожидаемыми

|Входные данные|Результат|Ожидаемый результат
|--------------|---------|-------------------
|хочу пойти в парикмахерскую пешком затем поехать в аптеку на автобусе|пешком парикмахерская аптека автобус|пешком парикмахерская аптека автобус
|хочу поехать в парк на велосипеде в течение одного часа затем заехать в кафе|парк велосипед один час кафе|парк велосипед один час кафе
|поеду в обувной магазин на машине потом в кино|машина обувной магазин кино|машина обувной магазин кино
|в библиотеку на машине и обратно|библиотека машина|библиотека машина|
|пойду в парк пешком далее в торговый центр на автобусе|парк пешком автобус торговый центр|парк пешком автобус торговый центр
|в салон красоты на велосипеде затем в бар на машине|салон красота велосипед машина бар|салон красота велосипед машина бар|
|хочу поехать в спортзал пешком затем в бассейн на автобусе|спортзал пешком бассейн автобус|спортзал пешком бассейн автобус|
|в ателье на машине затем в музей на велосипеде|машина ателье музей велосипед|машина ателье музей велосипед|
|пойду в кондитерскую пешком затем в кафетерий на автобусе|пешком кафетерий автобус|пешком кафетерий автобус|
|в банк на велосипеде затем в аптеку на машине|велосипед банк машина аптека|велосипед банк машина аптека|


#### Тестирование формирования JSON.

**Основное действующее лицо:** пользователь\
**Гарантия успеха:** в сформированном JSON верно подставлены все слова после распознавания ключевых слов\
**Триггер:** появление на сервере результата распознавания ключевых слов\
**Основной сценарий:** 
1. из поступающего на вход JSON выделяется текст и координаты текущего местоположения (первый шаг)
2. из текста выделяются ключевые слова (желаемая точка, желаемое время, тип транспортного средства) (предыдущий шаг)
3. на основе полученных данных формируется JSON для отправки на сервер

**Расширение:** см.случаи

Поле name всегда остается пустым, так как это имя собственное организации. При дальнейшем развитии проекта планируется обучить ML-алгоритм распознавать имена собственные заведений на русском, однако, на текущий момент библиотека не имеет такой функциональности. К примеру, "валберис" распознается как "борис". Плюс необходимо учесть вариативность произношения английских слов на русском. Но поскольку задача приложения - именно нечеткий поиск, то данный нюанс на данный момент не критичен.

**Случай 1** - указано время, место и тип ТС. Пример:\
"хочу поехать в парк на велосипеде в течение одного часа затем заехать на велосипеде в кафе около тридцати минут"

**Ожидаемый результат:** в JSON попадет вся информация из запроса.

**Выделенные ключевые слова:** "парк:place велосипед один час кафе:place велосипед тридцать минута". В данном случае у слов, обозначающих место, есть приписка ":place" - это нужно для подстановки слов в нужные поля JSON.

Полученный результат:

    {
    "id": "ed25f6ff-e860-4857-9305-d2ce8784b73f",
    "entries": [
        {
            "entryno": 1,
            "tsys": "bike",
            "time": 60,
            "startpoint": "FROM_CLIENT",
            "destpoint": {
                "name": "",
                "category": "парк"
            }
        },
        {
            "entryno": 2,
            "tsys": "bike",
            "time": 30,
            "startpoint": "PREVIOUS_POINT",
            "destpoint": {
                "name": "",
                "category": "кафе"
            }
        }
    ]
    }

Видим, что место, тип ТС и время определились верно. В стартовой точке стоит FROM_CLIENT, так как для теста координаты не подставлялись. PREVIOUS_POINT означает, что маршрут составной и что следующая часть маршрута стартует в предыдущей определенной точке. Тест пройден успешно. 

**Случай 2:** указано время и место, но тип ТС указан в первой части, но во второй части запроса не указан

**Ожидаемый результат:** во вторую часть запроса подставится тип ТС из 1-й части 

**Выделенные ключевые слова:** "парк:place велосипед один час кафе:place тридцать минута"

Полученный результат:

    {
    "id": "20a926c7-db9c-464b-a822-de02e31e75d5",
    "entries": [
        {
            "entryno": 1,
            "tsys": "bike",
            "time": 60,
            "startpoint": "FROM_CLIENT",
            "destpoint": {
                "name": "",
                "category": "парк"
            }
        },
        {
            "entryno": 2,
            "tsys": "bike",
            "time": 30,
            "startpoint": "PREVIOUS_POINT",
            "destpoint": {
                "name": "",
                "category": "кафе"
            }
        }
    ]
    }

Полученный результат совпал с ожидаемым

**Случай 3:** указано время и место, но тип не указан ни в первой части, ни во второй части

**Ожидаемый результат:** в обе части запроса подставится тип "пешеход"

**Выделенные ключевые слова:** "парк:place один час кафе:place тридцать минута"

Полученный результат:

    {
    "id": "81dcea4f-ccfc-4c1f-8270-9bde7fb62fb0",
    "entries": [
        {
            "entryno": 1,
            "tsys": "ped",
            "time": 60,
            "startpoint": "FROM_CLIENT",
            "destpoint": {
                "name": "",
                "category": "парк"
            }
        },
        {
            "entryno": 2,
            "tsys": "ped",
            "time": 30,
            "startpoint": "PREVIOUS_POINT",
            "destpoint": {
                "name": "",
                "category": "кафе"
            }
        }
    ]
    }

Полученный результат совпал с ожидаемым

**Случай 4:** указано место и тип ТС, но тип не указано время

**Ожидаемый результат:** должно подставиться время по умолчанию для каждого типа ТС

**Выделенные ключевые слова:** "парк:place велосипед кафе:place пешком"

Полученный результат:

    {
    "id": "39148728-743f-44e8-8180-0f9b12218ee2",
    "entries": [
        {
            "entryno": 1,
            "tsys": "bike",
            "time": 30,
            "startpoint": "FROM_CLIENT",
            "destpoint": {
                "name": "",
                "category": "парк"
            }
        },
        {
            "entryno": 2,
            "tsys": "ped",
            "time": 30,
            "startpoint": "PREVIOUS_POINT",
            "destpoint": {
                "name": "",
                "category": "кафе"
            }
        }
    ]
    }




#### Вывод

Составлены тест-кейсы как для всего проекта, так и для отдельно взятой Python-части. Все тесты для Python-части пройдены успешно.